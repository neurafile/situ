use wasm_bindgen::prelude::*;
use std::collections::HashMap;

// Parser module will be generated by ANTLR into src/parser/
// mod parser;

// Type for JavaScript callback functions
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);

    // Callback to play a sound file
    #[wasm_bindgen(js_name = "playSound")]
    fn js_play_sound(path: &str) -> i32;

    // Callback to stop a sound by ID
    #[wasm_bindgen(js_name = "stopSound")]
    fn js_stop_sound(id: i32);
}

#[wasm_bindgen]
pub struct GadgetVM {
    vm: vm::VM,
    active_sounds: HashMap<String, i32>, // Map note name to sound ID
}

#[wasm_bindgen]
impl GadgetVM {
    #[wasm_bindgen(constructor)]
    pub fn new() -> GadgetVM {
        GadgetVM {
            vm: vm::VM::new(),
            active_sounds: HashMap::new(),
        }
    }

    #[wasm_bindgen]
    pub fn parse(&mut self, source: &str) -> Result<String, String> {
        // TODO: Use generated parser from ANTLR
        // For now, return placeholder
        Ok(format!("{{\"status\": \"parsed\", \"source_length\": {}}}", source.len()))
    }

    #[wasm_bindgen]
    pub fn process(&mut self, input: &str) -> String {
        // Minimal language processing
        self.vm.process(input)
    }

    /// Play a sound file. Returns the sound ID, or -1 on error.
    /// The WASM manages which sounds are playing and can stop them.
    #[wasm_bindgen]
    pub fn play_sound(&mut self, path: &str, note_name: &str) -> i32 {
        // Stop any existing sound for this note
        if let Some(old_id) = self.active_sounds.get(note_name) {
            js_stop_sound(*old_id);
        }

        // Play the new sound
        let sound_id = js_play_sound(path);
        if sound_id >= 0 {
            self.active_sounds.insert(note_name.to_string(), sound_id);
        }
        sound_id
    }

    /// Stop a sound by note name
    #[wasm_bindgen]
    pub fn stop_sound(&mut self, note_name: &str) -> bool {
        if let Some(sound_id) = self.active_sounds.remove(note_name) {
            js_stop_sound(sound_id);
            true
        } else {
            false
        }
    }

    /// Stop all currently playing sounds
    #[wasm_bindgen]
    pub fn stop_all_sounds(&mut self) {
        for (_, sound_id) in self.active_sounds.drain() {
            js_stop_sound(sound_id);
        }
    }

    /// Get list of currently playing note names
    #[wasm_bindgen]
    pub fn get_active_sounds(&self) -> Vec<String> {
        self.active_sounds.keys().cloned().collect()
    }
}

// Minimal VM implementation
mod vm {
    pub struct VM {
        // Placeholder for VM state
    }

    impl VM {
        pub fn new() -> Self {
            VM {}
        }

        pub fn process(&self, input: &str) -> String {
            // Very minimal processing for now
            format!("Processed: {}", input)
        }
    }
}
